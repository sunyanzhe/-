# 浏览器缓存

## 强缓存
浏览器中的缓存作用分为两种情况, 一种是需要发送HTTP请求, 一种是不需要发送的
首先是检查强缓存, 这个阶段不需要发送HTTP请求
如何检查呢? 通过响应的字段来进行, 但是说这个字段就有点门道了

在HTTP/1.0 和 HTTP/1.1 中字段不一样, 1.0使用的是Expires, 而1.1使用的是Cache-Control

### Expires
Expires即过期回见, 存于服务器端返回的响应头中, 告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据, 无需再次请求

```http/1.0
Expires: Wed, 22 Nov 2019 08:41:00 GMT
```

表示资源在2019年11月22日8点41分过期, 过期了就得想服务端发请求

这个方式看上去没什么问题, 合情合理, 但其实隐藏了一个坑, 那就是服务器的时间和浏览器的时间可能不一致, 那服务器返回的这个过期时间可能就是不准确的. 因此这种方式很快在后来的HTTP1.1版本中被抛弃了.


### Cache-Control
在HTTP1.1中, 采用了非常关键的字段: Cache-Control. 
它和Expires本职的不同在于他没有采用具体的过期时间点这个方式, 而是采用过期时长来控制缓存, 对应的字段时max-age. 比如

```http/1.1
Cache-Control: max-age=3600
```

代表这个响应返回在3600秒, 也就是一个小时之内可以直接使用缓存
如果你觉得它只有max-age一个属性的话, 那就错了

他其实可以组合非常多的指令, 完成更多场景的缓存判断, 将一些关键的属性列举如下

1. public: 客户端和代理服务器都可以缓存. 因为一个请求可能要经过不同的代理服务器最后才打到目标服务器, 那么结果就是不仅仅浏览器可以缓存数据, 中间的任何代理节点都可以进行缓存

2. private: 这种情况就是只有浏览器能缓存了, 中间的代理服务器不能缓存

3. no-cache: 跳过当前的强缓存, 发送HTTP请求, 即直接进入协商缓存阶段

4. no-store: 非常粗暴, 不进行任何形式的缓存

5. s-maxage: 和max-age很像, 设置代理服务器的缓存时间


值得注意的是， 当Expires和Cache-Control同时存在的时候, Cache-Control会优先考虑

当然, 还存在一种情况, 当资源缓存时间超时了, 也就是强缓存失效了, 接下来了该怎么办?
那就是进入第二级屏障 ———— 协商缓存


## 协商缓存
强缓存失效之后, 浏览器的请求中携带相应的`缓存tag`来向服务器发请求, 由服务器根据这个tag, 来决定是否使用缓存, 这就是协商缓存

具体来说, 这样的`缓存tag`分为两种: `Last-Modified`和`ETag`. 这两者各有优劣, 并不存在谁对谁有绝对的优势, 跟上面强缓存的两个tag不一样

### Last-Modified
即最后修改时间. 在浏览器第一次给服务器发送请求后, 服务器会在响应头中加上这个字段

浏览器接收到后, 如果再次请求, 会在请求头中携带`If-Modified-Since`字段, 这个字段的值也就是服务器传来的最后修改时间.

服务器拿到请求头中的`If-Modified-Since`的字段后, 和服务器中该资源的最后修改时间做对比:

如果请求头中的这个值小于最后修改时间, 说明更新了. 返回新的资源, 跟常规的HTTP请求响应的流程一样
如果请求头中的这个值大于最后修改时间, 就返回304, 告诉浏览器直接使用缓存

### ETag
`ETag`是服务器根据当前文件的内容, 给文件生成的唯一表示, 只要里面的内容有变动, 这个值就会变. 服务器通过`响应头`把这个值给浏览器

浏览器接收到ETag的值, 会在下次请求时, 将这个值作为`If-None-Match`这个字段的内容, 并放到请求头中, 发给服务器

服务器接收到`If-None-Match`后, 会跟服务器上该资源的`ETag`做对比:
如果两者不一样, 说明要更新了, 返回新的资源, 跟常规的HTTP请求响应的流程一样
否则返回304, 告诉浏览器直接使用缓存

### 两者对比
1. 在精准度上, `ETag`要优于`Last-Modified`. 由于`ETag`是按照内容给资源上标识, 因此能准确感知资源的变化. 而Last-Modified就不一样了, 他在一些特殊情况不能准确感知资源变化,